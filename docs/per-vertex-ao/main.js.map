{"version":3,"sources":["webpack:///./src/global-regl.ts","webpack:///./src/createsamplecollection.ts","webpack:///./src/rendersamples.ts","webpack:///./src/reducesamples.ts","webpack:///./src/renderdepth.ts","webpack:///./src/utils/index.ts","webpack:///./src/index.ts","webpack:///./src/gl-matrix-extensions.ts","webpack:///./src/rendermodel.js"],"names":["REGL","__webpack_require__","exports","regl","gl_matrix_1","createSampleCollection","mesh","sampleDistance","oneMinusSampleDistance","Math","max","min","positions","normals","indices","vtxCount","length","triCount","samples","perVertex","Array","from","map","_","all","i","triPositions","vec3","create","triNormals","centroidPosition","centroidNormal","vtxIndices","tIdx","copyFromOffset","add","scale","normalize","sample","position","normal","scaleAndAdd","push","global_regl_1","utils_1","reducesamples_1","renderdepth_1","renderSamples","opts","Object","assign","near","far","fov","PI","sampleSize","sampleCount","sampleSizeSq","bufferSize","getSmallestPOTSize","Error","sampleBuffer","fbo","centerPos","tilesPerRow","floor","renderOpts","viewport","x","y","width","height","model","mat4","view","projection","perspective","buffer","elements","nearPlane","farPlane","use","clear","color","depth","sIdx","lookAt","UP","renderDepth","values","reduceSamples","destroy","destResolution","destBuffer","results","Float32Array","vert","vertShader","frag","fragShader","attributes","uniforms","source","size","sourceRes","count","pixels","read","toFixed","prop","cull","enable","face","framebuffer","undefined","colorFormat","colorType","elementCount","rendermodel_1","createsamplecollection_1","rendersamples_1","Promise","resolve","then","_a","sent","console","log","sampleCollection","sampleValues","value","ao","vtx","vtxSamples","vtxSampleCount","dist","totalDistance","distances","j","totalWeight","weight","renderModel","fromValues","DOWN","LEFT","RIGHT","ONE","ZERO","out","a","offset","r","__webpack_exports__","d","src_global_regl__WEBPACK_IMPORTED_MODULE_0__","gl_matrix__WEBPACK_IMPORTED_MODULE_1__","geo_center__WEBPACK_IMPORTED_MODULE_2__","geo_center__WEBPACK_IMPORTED_MODULE_2___default","n","trackball_controller__WEBPACK_IMPORTED_MODULE_3__","trackball_controller__WEBPACK_IMPORTED_MODULE_3___default","canvas","document","getElementsByTagName","center","trackball","onRotate","loop","drag","render","occlusion","zoom","clientWidth","clientHeight","rotation","window","addEventListener","e","deltaY","spin"],"mappings":"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","file":"main.js","sourcesContent":["import REGL = require(\"regl\");\r\nexport const regl = REGL();\r\n","import {vec3} from \"gl-matrix\";\r\n\r\nexport interface Sample {\r\n\tposition: vec3;\r\n\tnormal: vec3;\r\n\tvalue?: number;\r\n}\r\n\r\nexport interface SampleCollection {\r\n\tall: Sample[];\r\n\tperVertex: Record<number, Sample[]>;\r\n}\r\n\r\n/**\r\n * Creates an array of \"samples\" across the triangles of a mesh, to be used\r\n * for sampling AO etc.\r\n * \r\n * @param mesh Mesh with positions, normals and indices.\r\n * @param sampleDistance Normalized distance between 0..1 which determines if samples should\r\n * \t\t\t\t\t\tbe generated close to each vertex (values near 0) or close to\r\n * \t\t\t\t\t\tthe centroid of each triangle (values near 1).\r\n * \t\t\t\t\t\tNote that setting 0 as value will lead to a lot of duplicate samples\r\n * \t\t\t\t\t\thaving the same position, since each vertex can be shared between\r\n * \t\t\t\t\t\tseveral triangles.\r\n */\r\nexport function createSampleCollection(mesh: { positions: number[], normals: number[], indices: number[] }, sampleDistance: number): SampleCollection {\r\n\t// Sample-distance is normalized. 0 means @ the vertex, 1 means @ the centroid.\r\n\t// Values closer to 1 means all samples will be clumped closer together in the\r\n\t// center of the triangle.\r\n\tsampleDistance = Math.max(Math.min(sampleDistance || 0, 1), 0);\r\n\tconst oneMinusSampleDistance = 1 - sampleDistance;\r\n\r\n\tconst {positions, normals, indices} = mesh;\r\n\tconst vtxCount = positions.length / 3;\r\n\tconst triCount = indices.length / 3;\r\n\r\n\tconst samples: SampleCollection = {\r\n\t\tperVertex: Array.from({ length: vtxCount }).map(_ => []),\r\n\t\tall: []\r\n\t};\r\n\r\n\tif (!positions || !normals || !indices) {\r\n\t\treturn samples;\r\n\t}\r\n\r\n\tconst triPositions = [vec3.create(), vec3.create(), vec3.create()];\r\n\tconst triNormals = [vec3.create(), vec3.create(), vec3.create()];\r\n\tconst centroidPosition = vec3.create();\r\n\tconst centroidNormal = vec3.create();\r\n\tconst vtxIndices = vec3.create();\r\n\r\n\tlet i: number;\r\n\r\n\tfor (let tIdx = 0; tIdx < triCount; tIdx++) {\r\n\t\tvec3.copyFromOffset(vtxIndices, indices, tIdx * 3);\r\n\r\n\t\t// Fetch positions and normals for the triangle.\r\n\t\tfor (i = 0; i < 3; i++) {\r\n\t\t\tvec3.copyFromOffset(triPositions[i], positions, vtxIndices[i] * 3);\r\n\t\t\tvec3.copyFromOffset(triNormals[i], normals, vtxIndices[i] * 3);\r\n\t\t}\r\n\r\n\t\t// Calculate centroid position.\t\t\r\n\t\tvec3.add(centroidPosition, triPositions[0], triPositions[1]);\r\n\t\tvec3.add(centroidPosition, centroidPosition, triPositions[2]);\r\n\t\tvec3.scale(centroidPosition, centroidPosition, 1 / 3);\r\n\r\n\t\t// Calculate centroid normal.\r\n\t\tvec3.add(centroidNormal, triNormals[0], triNormals[1]);\r\n\t\tvec3.add(centroidNormal, centroidNormal, triNormals[2]);\r\n\t\tvec3.normalize(centroidNormal, centroidNormal);\r\n\r\n\t\t// Calculate samples for the triangle.\r\n\t\tfor (i = 0; i < 3; i++) {\r\n\t\t\tconst sample: Sample = {\r\n\t\t\t\tposition: vec3.create(),\r\n\t\t\t\tnormal: vec3.create()\r\n\t\t\t};\r\n\r\n\t\t\t// Calculate sample-position.\r\n\t\t\tvec3.scale(sample.position, triPositions[i], oneMinusSampleDistance);\r\n\t\t\tvec3.scaleAndAdd(sample.position, sample.position, centroidPosition, sampleDistance);\r\n\r\n\t\t\t// Calculate sample-normal.\r\n\t\t\tvec3.scale(sample.normal, triNormals[i], oneMinusSampleDistance);\r\n\t\t\tvec3.scaleAndAdd(sample.normal, sample.normal, centroidNormal, sampleDistance);\r\n\t\t\tvec3.normalize(sample.normal, sample.normal);\r\n\r\n\t\t\tsamples.perVertex[vtxIndices[0]].push(sample);\r\n\t\t\tsamples.perVertex[vtxIndices[1]].push(sample);\r\n\t\t\tsamples.perVertex[vtxIndices[2]].push(sample);\r\n\r\n\t\t\tsamples.all.push(sample);\r\n\t\t}\r\n\t}\r\n\r\n\treturn samples;\r\n};\r\n","import REGL = require(\"regl\");\r\nimport {mat4, vec3} from \"gl-matrix\";\r\nimport {regl} from \"src/global-regl\";\r\nimport {fbo, getSmallestPOTSize} from \"src/utils\";\r\nimport {reduceSamples} from \"src/reducesamples\";\r\nimport {renderDepth} from \"./renderdepth\";\r\n\r\ninterface RenderOptions {\r\n\tnear: number;\r\n\tfar: number;\r\n\tfov: number;\r\n\tsampleSize: number;\r\n}\r\n\r\nexport const renderSamples = async function (mesh: { positions: number[], indices: number[] }, samples: any[], opts?: Partial<RenderOptions>) {\r\n\topts = Object.assign({\r\n\t\tnear: 0.2,\r\n\t\tfar: 7,\r\n\t\tfov: Math.PI * 0.45,\r\n\t\tsampleSize: 8\r\n\t}, opts || {});\r\n\r\n\tconst sampleCount = samples.length;\r\n\tconst sampleSizeSq = opts.sampleSize * opts.sampleSize;\r\n\tconst bufferSize = getSmallestPOTSize(sampleCount * sampleSizeSq);\r\n\r\n\tif (bufferSize > 4096) {\r\n\t\tthrow new Error(\"Too large buffer!\");\r\n\t}\r\n\r\n\tconst sampleBuffer = fbo(bufferSize);\r\n\r\n\tconst centerPos = vec3.create();\r\n\tconst tilesPerRow = Math.floor(bufferSize / opts.sampleSize);\r\n\r\n\tconst renderOpts = {\r\n\t\tviewport: {\r\n\t\t\tx: 0,\r\n\t\t\ty: 0,\r\n\t\t\twidth: opts.sampleSize,\r\n\t\t\theight: opts.sampleSize\r\n\t\t} as REGL.BoundingBox,\r\n\t\tmodel: mat4.create(),\r\n\t\tview: mat4.create(),\r\n\t\tprojection: mat4.perspective(mat4.create(), opts.fov, 1, opts.near, opts.far),\r\n\t\tpositions: regl.buffer(mesh.positions),\r\n\t\tindices: regl.elements(mesh.indices),\r\n\t\tnearPlane: opts.near,\r\n\t\tfarPlane: opts.far\r\n\t};\r\n\r\n\t// Render a viewport for each sample, and store them as tiles in the buffer.\r\n\tsampleBuffer.use(_ => {\r\n\t\tregl.clear({ color: [1,1,1,1], depth: 1 });\r\n\r\n\t\tfor (let sIdx = 0; sIdx < sampleCount; sIdx++) {\r\n\t\t\tconst sample = samples[sIdx];\r\n\r\n\t\t\t// Update view-matrix for the sample.\r\n\t\t\tvec3.add(centerPos, sample.position, sample.normal);\r\n\t\t\tmat4.lookAt(renderOpts.view, sample.position, centerPos, vec3.UP);\r\n\r\n\t\t\t// Move viewport to the correct tile.\r\n\t\t\trenderOpts.viewport.x = (sIdx % tilesPerRow) * opts.sampleSize;\r\n\t\t\trenderOpts.viewport.y = (Math.floor(sIdx / tilesPerRow)) * opts.sampleSize;\r\n\r\n\t\t\trenderDepth(renderOpts);\r\n\t\t}\r\n\t});\r\n\r\n\t// Reduce to an array with a single mean-value per sample.\r\n\tconst values = reduceSamples(sampleBuffer, opts.sampleSize, sampleCount);\r\n\r\n\tsampleBuffer.destroy();\r\n\treturn values;\r\n};\r\n\r\n","import REGL = require(\"regl\");\r\nimport {regl} from \"src/global-regl\";\r\nimport {fbo, getSmallestPOTSize} from \"src/utils\";\r\n\r\nexport function reduceSamples(sampleBuffer: REGL.Framebuffer2D, sampleSize: number, sampleCount: number) {\r\n\tconst destResolution = getSmallestPOTSize(sampleCount);\r\n\tconst destBuffer = fbo(destResolution);\r\n\tconst results = new Float32Array(sampleCount);\r\n\r\n\tdestBuffer.use(_ => {\r\n\t\tregl({\r\n\t\t\tvert: vertShader,\r\n\t\t\tfrag: fragShader(sampleSize),\r\n\t\t\tattributes: {\r\n\t\t\t\tposition: [-1,-1, 1,-1, 1,1, -1,-1, 1,1, -1,1],\r\n\t\t\t},\r\n\t\t\tuniforms: {\r\n\t\t\t\tsource: sampleBuffer,\r\n\t\t\t\tsize: [destResolution, destResolution],\r\n\t\t\t\tsourceRes: [(sampleBuffer as any).width, (sampleBuffer as any).height],\r\n\t\t\t\tsampleSize: [sampleSize, sampleSize],\r\n\t\t\t},\r\n\t\t\tcount: 6\r\n\t\t})();\r\n\t\r\n\t\tconst pixels = regl.read();\r\n\t\r\n\t\t// Just use the R-channel from each pixel (assume it's grayscale).\r\n\t\tfor (let i = 0; i < sampleCount; i++) {\r\n\t\t\tresults[i] = pixels[i * 4] / 255;\r\n\t\t}\t\r\n\t});\r\n\r\n\tdestBuffer.destroy();\r\n\r\n\treturn results;\r\n};\r\n\r\nconst vertShader = `\r\n\tprecision highp float;\r\n\tattribute vec2 position;\r\n\r\n\tvoid main() {\r\n\t\tgl_Position = vec4(position, 0, 1);\r\n\t}\r\n`;\r\n\r\nconst fragShader = (sampleSize: number) =>  `\r\n\tprecision mediump float;\r\n\tuniform sampler2D source;\r\n\tuniform vec2 size, sampleSize;\r\n\r\n\tvoid main() {\r\n\t\tfloat brightness = 0.0;\r\n\t\tvec2 lowerBound = (gl_FragCoord.xy - vec2(0.5)) / size;\r\n\t\tvec2 upperBound = (gl_FragCoord.xy + vec2(0.5)) / size;\r\n\r\n\t\tfor (float y = 0.0; y < 1.0; y+= ${( 1 / sampleSize).toFixed(4)}) {\r\n\t\t\tfor (float x = 0.0; x < 1.0; x += ${(1 / sampleSize).toFixed(4)}) {\r\n\t\t\t\tvec2 texel = vec2(mix(lowerBound.x, upperBound.x, x), mix(lowerBound.y, upperBound.y, y));\r\n\t\t\t\tbrightness = brightness + texture2D(source, texel).r;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tbrightness = brightness / (sampleSize.x * sampleSize.y);\r\n\t\tgl_FragColor = vec4(brightness, 0, 0, 1);\r\n\t}\r\n`;\r\n","import REGL = require(\"regl\");\r\nimport {regl} from \"src/global-regl\";\r\n\r\ninterface Uniforms {\r\n\tmodel: REGL.Mat4;\r\n\tview: REGL.Mat4;\r\n\tprojection: REGL.Mat4;\r\n\tnearPlane: number;\r\n\tfarPlane: number;\r\n}\r\n\r\ninterface Attributes {\r\n\tposition: REGL.Buffer;\r\n}\r\n\r\ninterface Props {\r\n\tpositions: REGL.Buffer;\r\n\tindices: REGL.Elements;\r\n\tmodel: REGL.BufferData;\r\n\tview: REGL.BufferData;\r\n\tprojection: REGL.BufferData;\r\n\tviewport: REGL.BoundingBox;\r\n\tnearPlane: number;\r\n\tfarPlane: number;\r\n}\r\n\r\n/**\r\n * Renders the normalized depth (from the camera) of the geometry as grayscale.\r\n * Use {near} and {far} to control the mapping of depth to color.\r\n * Usually set them to the same\r\n * as your near- and far plane for the camera.\r\n */\r\nexport const renderDepth = regl<Uniforms, Attributes, Props>({\r\n\tvert: `\r\n\t\tprecision highp float;\r\n\t\tattribute vec3 position;\r\n\t\tuniform mat4 model, view, projection;\r\n\t\tuniform float farPlane, nearPlane;\r\n\t\tvarying vec3 distance;\r\n\r\n\t\tvoid main() {\r\n\t\t\tvec4 cs_position = view * model * vec4(position, 1);\r\n\t\t\tdistance = vec3(min(((-cs_position.z - nearPlane) / (farPlane - nearPlane)), 1.0));\r\n\t\t\tgl_Position = projection * cs_position;\r\n\t\t}\r\n\t`,\r\n\tfrag: `\r\n\t\tprecision highp float;\r\n\t\tvarying vec3 distance;\r\n\r\n\t\tvoid main() {\r\n\t\t\tgl_FragColor = vec4(distance, 1);\r\n\t\t}\r\n\t`,\r\n\tattributes: {\r\n\t\tposition: regl.prop<Props, \"positions\">(\"positions\"),\r\n\t},\r\n\tuniforms: {\r\n\t\tmodel: regl.prop<Props, \"model\">(\"model\"),\r\n\t\tview: regl.prop<Props, \"view\">(\"view\"),\r\n\t\tprojection: regl.prop<Props, \"projection\">(\"projection\"),\r\n\t\tnearPlane: regl.prop<Props, \"nearPlane\">(\"nearPlane\"),\r\n\t\tfarPlane: regl.prop<Props, \"farPlane\">(\"farPlane\"),\r\n\t},\r\n\telements: regl.prop<Props, \"indices\">(\"indices\"),\r\n\tviewport: regl.prop<Props, \"viewport\">(\"viewport\"),\r\n\tcull: { enable: false, face: \"back\" }\r\n});\r\n\r\n","import REGL = require(\"regl\");\r\nimport {regl} from \"src/global-regl\";\r\n\r\n/**\r\n * Creates a basic framebuffer with uint8-elements.\r\n * \r\n * @param width Width of the buffer.\r\n * @param height (Optional, default is same as width) Height of the buffer.\r\n */\r\nexport function fbo(width: number, height?: number): REGL.Framebuffer2D {\r\n\treturn regl.framebuffer({\r\n\t\twidth: width,\r\n\t\theight: height !== undefined ? height : width,\r\n\t\tcolorFormat: \"rgba\",\r\n\t\tcolorType: \"uint8\",\r\n\t});\r\n}\r\n\r\n/**\r\n * Calculates the smallest Power Of Two-size that can hold {elementCount}\r\n * number of elements.\r\n * Example:\r\n * \r\n *\tif {elementCount} is 63,\r\n *\tthe returned size is 8 (8x8 == 64, which can hold 63 elements).\r\n * \r\n * @param elementCount Number of elements / pixels that the size must be able to contain.\r\n */\r\nexport function getSmallestPOTSize(elementCount: number): number {\r\n\tlet size = 1;\r\n\r\n\twhile (size * size < elementCount) {\r\n\t\tsize *= 2;\r\n\t}\r\n\r\n\treturn size;\r\n}\r\n","require(\"src/gl-matrix-extensions\");\r\n\r\nimport {vec3} from \"gl-matrix\";\r\nimport {renderModel} from \"src/rendermodel\";\r\nimport {createSampleCollection} from \"src/createsamplecollection\";\r\nimport {renderSamples} from \"src/rendersamples\";\r\n\r\n(async function main() {\r\n\tconst mesh: any = await import(\"resources/pirate_ship.json\");\r\n\tconst vtxCount = mesh.positions.length / 3;\r\n\tconst triCount = mesh.indices.length / 3;\r\n\r\n\tconsole.log(`Vertices: ${vtxCount}, Triangles: ${triCount}`);\r\n\r\n\tconst sampleCollection = createSampleCollection(mesh, 0.2);\r\n\r\n\tconst sampleValues = await renderSamples(mesh, sampleCollection.all, {\r\n\t\tnear: 0.08,\r\n\t\tfar: 5,\r\n\t\tfov: Math.PI * 0.5,\r\n\t\tsampleSize: 4\r\n\t});\r\n\r\n\t// Put values into each corresponding sample-object.\r\n\tfor (let i = 0; i < sampleValues.length; i++) {\r\n\t\tsampleCollection.all[i].value = sampleValues[i];\r\n\t}\r\n\r\n\t// Calculate AO for each vertex from the samples.\r\n\tconst ao = new Float32Array(vtxCount);\r\n\tconst vtx = vec3.create();\r\n\r\n\tfor (let i = 0; i < vtxCount; i++) {\r\n\t\tconst vtxSamples = sampleCollection.perVertex[i];\r\n\t\tconst vtxSampleCount = vtxSamples.length;\r\n\r\n\t\tvec3.copyFromOffset(vtx, mesh.positions, i * 3);\r\n\r\n\t\tlet dist = 0;\r\n\t\tlet totalDistance = 0;\r\n\r\n\t\tlet distances = [];\r\n\t\tlet values = [];\r\n\r\n\t\t// Calculate distances and store them together with the values.\r\n\t\tfor (let j = 0; j < vtxSampleCount; j++) {\r\n\t\t\tdist = vec3.dist(vtx, vtxSamples[j].position);\r\n\t\t\ttotalDistance += dist;\r\n\r\n\t\t\tdistances.push(dist);\r\n\t\t\tvalues.push(1 - vtxSamples[j].value);\t// Switch from light to occlusion.\r\n\t\t}\r\n\r\n\t\tlet value = 0;\r\n\t\tlet totalWeight = 0;\r\n\r\n\t\t// Apply values weighted by distance.\r\n\t\tfor (let j = 0; j < vtxSampleCount; j++) {\r\n\t\t\tlet weight = 1 - (distances[j] / totalDistance);\r\n\t\t\ttotalWeight += weight;\r\n\r\n\t\t\tvalue += values[j] * weight;\r\n\t\t}\r\n\r\n\t\tvalue = value / totalWeight;\r\n\t\tao[i] = 1 - value;\r\n\t}\r\n\r\n\trenderModel(mesh, ao);\r\n})();\r\n","import {vec3} from \"gl-matrix\";\r\n\r\ndeclare module \"gl-matrix\" {\r\n\texport namespace vec3 {\r\n        /**\r\n         * Copy the values from one vec3 to another\r\n         *\r\n         * @param out the receiving vector\r\n         * @param a the source vector\r\n\t\t * @param offset the offset in the source vector to start copying values from.\r\n         * @returns out\r\n         */\r\n\t\tfunction copyFromOffset(out: vec3, a: vec3 | number[], offset: number): vec3;\r\n\t\t\r\n\t\tlet UP: vec3;\r\n\t\tlet DOWN: vec3;\r\n\t\tlet LEFT: vec3;\r\n\t\tlet RIGHT: vec3;\r\n\t\tlet ONE: vec3;\r\n\t\tlet ZERO: vec3;\r\n\t}\r\n}\r\n\r\nvec3.UP = vec3.fromValues(0, 1, 0);\r\nvec3.DOWN = vec3.fromValues(0, -1, 0);\r\nvec3.LEFT = vec3.fromValues(-1, 0, 0);\r\nvec3.RIGHT = vec3.fromValues(1, 0, 0);\r\nvec3.ONE = vec3.fromValues(1, 1, 1);\r\nvec3.ZERO = vec3.fromValues(0, 0, 0);\r\n\r\nvec3.copyFromOffset = function(out: vec3, a: vec3 | number[], offset: number): vec3 {\r\n\tout[0] = a[offset + 0];\r\n\tout[1] = a[offset + 1];\r\n\tout[2] = a[offset + 2];\r\n\treturn out;\r\n};\r\n","\"use strict\";\r\n\r\nimport {regl} from \"src/global-regl\";\r\nimport { mat4 } from \"gl-matrix\";\r\nimport center from \"geo-center\";\r\nimport Trackball from \"trackball-controller\";\r\n\r\nexport function renderModel(mesh, ao) {\r\n\tconst canvas = document.getElementsByTagName(\"canvas\")[0];\r\n\r\n\tmesh.positions = center(mesh.positions, { center: [0, -0.5, 0] });\r\n\t\r\n\tvar trackball = new Trackball(\r\n\t\tcanvas, {\r\n\t\t\tonRotate: loop,\r\n\t\t\tdrag: 0.01\r\n\t\t}\r\n\t);\r\n\r\n\tconst render = regl({\r\n\t\tvert: `\r\n\t\t\tprecision highp float;\r\n\t\t\tattribute vec3 position;\r\n\t\t\tattribute vec3 normal;\r\n\t\t\tattribute float occlusion;\r\n\t\t\tuniform mat4 model, view, projection;\r\n\t\t\tvarying float vOcclusion;\r\n\r\n\t\t\tvoid main() {\r\n\t\t\t\tgl_Position = projection * view * model * vec4(position, 1);\r\n\t\t\t\tvOcclusion = occlusion;\r\n\t\t\t}\r\n\t\t`,\r\n\t\tfrag: `\r\n\t\t\tprecision highp float;\r\n\t\t\tvarying float vOcclusion;\r\n\r\n\t\t\tvoid main() {\r\n\t\t\t\tgl_FragColor = vec4(1.0 * vec3(vOcclusion), 1.0);\r\n\t\t\t}\r\n\t\t`,\r\n\t\tattributes: {\r\n\t\t\tposition: mesh.positions,\r\n\t\t\tocclusion: ao\r\n\t\t},\r\n\t\tuniforms: {\r\n\t\t\tmodel: regl.prop('model'),\r\n\t\t\tview: regl.prop('view'),\r\n\t\t\tprojection: regl.prop('projection')\r\n\t\t},\r\n\t\tviewport: regl.prop('viewport'),\r\n\t\telements: mesh.indices,\r\n\t\tcull: {\r\n\t\t\tenable: true,\r\n\t\t\tface: 'back'\r\n\t\t},\r\n\t});\r\n\r\n\t// Handle mousewheel zoom.\r\n\tlet zoom = 32;\r\n\t\r\n\twindow.addEventListener('wheel', function(e) {\r\n\t\tif (e.deltaY < 0) {\r\n\t\t\tzoom *= 0.9;\r\n\t\t} else if (e.deltaY > 0) {\r\n\t\t\tzoom *= 1.1;\r\n\t\t}\r\n\r\n\t\tzoom = Math.max(2, Math.min(64, zoom));\r\n\t\tloop();\r\n\t});\r\n\r\n\tfunction loop() {\r\n\t\tcanvas.width = canvas.clientWidth;\r\n\t\tcanvas.height = canvas.clientHeight;\r\n\r\n\t\tconst model = trackball.rotation;\r\n\t\tconst view = mat4.lookAt([], [0, 0, zoom], [0, 0, 0], [0, 1, 0]);\r\n\t\tconst projection = mat4.perspective([], Math.PI / 4, canvas.width / canvas.height, 0.1, 1000);\r\n\r\n\t\tregl.clear({\r\n\t\t\tcolor: [0.3, 0.3, 0.3, 1],\r\n\t\t\tdepth: 1\r\n\t\t});\r\n\r\n\t\trender({\r\n\t\t\tmodel: model,\r\n\t\t\tview: view,\r\n\t\t\tprojection: projection,\r\n\t\t\tviewport: {\r\n\t\t\t\tx: 0, y: 0,\r\n\t\t\t\twidth: canvas.width,\r\n\t\t\t\theight: canvas.height\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\ttrackball.spin(15,0);\r\n}\r\n"],"sourceRoot":""}